<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Syngnath个人技术博客-攀登代码之巅</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://syngnath.top/"/>
  <updated>2019-05-26T15:15:38.992Z</updated>
  <id>http://syngnath.top/</id>
  
  <author>
    <name>Syngnath</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity研究：C#和Unity的Event事件区别与使用</title>
    <link href="http://syngnath.top/2019/05/26/Unity/CSharp%E5%92%8CUnity%E7%9A%84Event%E4%BA%8B%E4%BB%B6%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://syngnath.top/2019/05/26/Unity/CSharp和Unity的Event事件区别与使用/</id>
    <published>2019-05-26T04:45:00.000Z</published>
    <updated>2019-05-26T15:15:38.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在设计游戏趋向于事件驱动，即当一个事件发生时，如主角捡到一个血包，发射一颗子弹，或者想让游戏里所有的物体需要进入第二阶段的状态，通过一个事件广播给游戏中的相关对象，使它们根据该恰当做出反应，从而使游戏驱动起来。事件一般是以<strong>数据包</strong>形式送出，其包含事件的信息，如发送者，或者时间戳等，当然根据实际情况作出改变。而这些的一切都要围绕<strong>Event</strong>作为核心，不过在说明Event之前先了解它的前身–<strong>delegate</strong>。</p><h1 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h1><h2 id="委托的基本声明和基本使用"><a href="#委托的基本声明和基本使用" class="headerlink" title="委托的基本声明和基本使用"></a>委托的基本声明和基本使用</h2><p>先看下委托的定义：<br><em>C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</em></p><p>简单来说，<strong>委托就是存储方法容器</strong>。C# 基于这个基础做了一定优化封装。下面介绍下delegate基本使用:<br>我想声明一个叫BroadCast的委托，将来用于存放方法，它接收string参数，并且返回值为void。而声明一个委托相当于声明一个新类，所有可以声明类的地方都可以声明委托。<br><code>public delegate void BroadCast(string msg);</code><br>这样它就是个可以存放和它标签一样，即同样是接收string参数，返回void的方法。</p><p>接着我们使用它去定义一些事件容器，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public BroadCast broadCastA;</span><br><span class="line">public BroadCast broadCastB;</span><br></pre></td></tr></table></figure></p><p>好了，接着在下面添加两个方法，一个叫BroadCastCore，用于调用委托里存放的东西，另外一个叫Func1的方法，Func1存放到broadCastA内，和broadCastA具备同样的标签，只要对broadCastA执行Invoke方法并且传递对应参数，那么里面存放的对应方法就会被调用并且接受到传递过来的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void BroadCastCore()&#123;</span><br><span class="line">  // new一个委托对象</span><br><span class="line">  broadCastA = Func1; //或者broadCastA = new broadCastA(Func1); 前者实际上等于后者，只是编译器帮忙省略了new的步骤</span><br><span class="line">  // 调用委托</span><br><span class="line">  broadCastA.Invoke(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Func1(string receiveMsg)&#123;</span><br><span class="line">  print(&quot;I Receive the msg : receiveMsg&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h2><p>多播委托使用了一个叫<strong>委托链</strong>的概念，简单来说就是把很多方法存放到一个容器中，然后调用这个容器时容器会将里面的方法每个都调用一次。<br>使用 <code>+=</code> 关键词可以注册方法<br>broadCastA += Func1;<br>broadCastA += Func2;<br>broadCastA += Func3;</p><p>使用 <code>-=</code> 关键词可以卸掉原来注册方法<br>broadCastA -= Func1;<br>broadCastA -= Func2;<br>broadCastA -= Func3;<br>所以对相关包含委托类封装时要提供注册和卸除两个方法</p><p>但是这里有个坑，因为一旦不小心使用了 <code>=</code> 就会重置覆盖掉之前所有注册的方法如：<br>broadCastA += Func1;<br>broadCastA += Func2;<br>broadCastA = Func3;<br>事实上只存放Func3方法。</p><p>所以接下来介绍下面的 ‘event’ 修饰关键词</p><h2 id="event修饰词"><a href="#event修饰词" class="headerlink" title="event修饰词"></a>event修饰词</h2><p>在原来委托定义基础上，加上event修饰词：<br>public event BroadCast broadCastA;<br>好了，现在 <code>=</code> 就会被禁止使用了，只能使用 <code>+=</code> 和 <code>-=</code> 增加和删除，所以这就是多播委托的最终形态了。</p><h1 id="UnityEvent"><a href="#UnityEvent" class="headerlink" title="UnityEvent"></a>UnityEvent</h1><p>UnityEvent基于C#委托的基础作出一定的封装，并且融入到Unity框架里，既可以把它当做一个普通委托在脚本中使用，也可以把它public在Unity面板中拖拽注册事件。</p><h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><p>创建一个继承UnityEvent的类即可如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class BossEvent : UnityEvent&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和之前上面c#委托声明 <code>public delegate void BroadCast(string msg);</code> 一个意思</p><p>接着定义一个事件容器，用属性来自动new一个Event对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BossEvent informEvent;</span><br><span class="line">public InformEvent </span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        if (informEvent == null)</span><br><span class="line">            informEvent = new BossEvent();</span><br><span class="line">        return informEvent;</span><br><span class="line">    &#125;</span><br><span class="line">    set &#123; informEvent = value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h2><p>首先F12看UnityEvent写了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespace UnityEngine.Events</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class UnityEvent&lt;T0&gt; : UnityEventBase</span><br><span class="line">    &#123;</span><br><span class="line">        [RequiredByNativeCode]</span><br><span class="line">        public UnityEvent();</span><br><span class="line"></span><br><span class="line">        public void AddListener(UnityAction&lt;T0&gt; call);</span><br><span class="line">        public void Invoke(T0 arg0);</span><br><span class="line">        public void RemoveListener(UnityAction&lt;T0&gt; call);</span><br><span class="line">        protected override MethodInfo FindMethod_Impl(string name, object targetObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要传入UnityAction声明的参数，尝试声明一个UnityAction发现它利用多态性封装了0-4个泛型参数的Action无返回值委托<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public delegate void UnityAction();</span><br><span class="line">public delegate void UnityAction&lt;T0&gt;(T0 arg0);</span><br><span class="line">public delegate void UnityAction&lt;T0, T1&gt;(T0 arg0, T1 arg1);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>那么明白本质后用起来就很简单了</p><ul><li>Lambada<br>informEvent.AddListener((msg)=&gt;{print(“Get Msg:” + msg)});<br>Lambada法力无边，另外注意Lambada里面方法如果调用外部变量，可能会导致GC</li><li>方法<br>informEvent.AddListener(同样签名方法名);</li></ul><h1 id="EventSystem和Event"><a href="#EventSystem和Event" class="headerlink" title="EventSystem和Event"></a>EventSystem和Event</h1><p>Unity里的EventSystem和Event主要是负责一些UI状态，用户输入输出，鼠标点击等事件的封装和监控。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class Example : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    void OnGUI()</span><br><span class="line">    &#123;</span><br><span class="line">        Event m_Event = Event.current;</span><br><span class="line"></span><br><span class="line">        if (m_Event.type == EventType.MouseDown)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;Mouse Down.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (m_Event.type == EventType.MouseDrag)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;Mouse Dragged.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (m_Event.type == EventType.MouseUp)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;Mouse Up.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>这里不再阐述，其主要是负责Unity框架内事件的监听和接口封装，有需要使用时查API即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>事件驱动模式可以帮助我们解决不同模块间的交流而不得不对象持有相互对象从而导致耦合性增加的问题，比较常用主要是两种：</p><ul><li><p>订阅-广播 模式<br>通过封装一个&lt;string, UnityEvent&gt;字典，提供事件的注册和卸除接口,再创建一个数据包的类DataBundle封装数据，从而实现广播数据包给已注册的对象。<br>DataBundle可以封装一个&lt;string, object&gt;用于存放一些事件属性或者其他任意的东西，从而使事件本身带有一些数据或者一些状态，一些属性，更加多样化。</p></li><li><p>主动监听模式<br>核心思想是<strong>谁感兴趣，谁主动监听</strong>，一般使用观察者模式是在比较具体的模块上使用，根据实际情况增添相应的接口。下面举个例子：</p><ul><li><p><strong>枚举类EventType</strong>：<br>存放事件，里面的事件对应的编号要明确写出，不要自动迭代</p></li><li><p><strong>管理类EventMng</strong>：<br>EventType 定义的变量 eventMain<br>提供一个事件的监听方法<br><code>Observe(EventType type){return eventMain==type;}</code><br>给外部监听<br>提供一个事件的触发方法<br><code>Trigger(EventType type){}</code><br>给外部触发<br>Update：监控eventMain，如果eventMain不为null，则在<strong>下一帧</strong>清除</p></li><li><p><strong>兴趣类Person</strong>:<br>这时候假设有个类Person对EventType里某个事件感兴趣<br>这时候只要在update里<br>if(EventMng.Instance.Observe()){<br>//执行代码段<br>}<br>就能监听对应事件执行相应代码</p></li></ul></li></ul><p><strong>可以看到，主动监听模式使用起来比较简单，并且不需要事件的注册，只需要一个存放事件一帧的容器即可，简单，有效</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在设计游戏趋向于事件驱动，即当一个事件发生时，如主角捡到一个血包，发射一颗子弹，或者想让游戏里所有的物体需要进入第二阶段的状态，通过一个事
      
    
    </summary>
    
      <category term="Unity" scheme="http://syngnath.top/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://syngnath.top/tags/Unity/"/>
    
      <category term="C#" scheme="http://syngnath.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown一些使用诀窍</title>
    <link href="http://syngnath.top/2019/05/25/%E9%9A%8F%E7%AC%94/Markdown%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E8%AF%80%E7%AA%8D/"/>
    <id>http://syngnath.top/2019/05/25/随笔/Markdown一些使用诀窍/</id>
    <published>2019-05-25T04:19:00.000Z</published>
    <updated>2019-05-26T15:15:38.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown阅读器"><a href="#Markdown阅读器" class="headerlink" title="Markdown阅读器"></a>Markdown阅读器</h1><p>这里推荐 <code>VsCode</code> ，微软老牌阅读器<br>vscode要安装增强插件来更好支持markdown</p><h2 id="插件："><a href="#插件：" class="headerlink" title="插件："></a>插件：</h2><p>GitLens – Git分支显示<br>Markdown Preview Enhanced – 支持Markdown外部导入<br>vscode-pdf –支持pdf显示<br>MarkdownAllinOne – 快捷键</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">Markdown基本语法</a><br><a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/" target="_blank" rel="noopener">Markdown增强插件使用说明</a></p><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级</span><br><span class="line">### 三级</span><br><span class="line"></span><br><span class="line">分割线：</span><br><span class="line">---</span><br><span class="line">- 列表1级</span><br><span class="line">    - 列表二级Tab + “-”</span><br><span class="line">        - 列表三级</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">- 2.afwaf</span><br><span class="line">-有一个以上就行</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line"></span><br><span class="line">姓名|班别|学号</span><br><span class="line">:--:|:--:|:--:</span><br><span class="line">yeshujun|2-class|1502</span><br><span class="line">moss|3-class|1504</span><br><span class="line"></span><br><span class="line">姓名|班别|学号</span><br><span class="line">--|--|--</span><br><span class="line">yeshujun|2-class|1502</span><br><span class="line">moss|3-class|1504</span><br><span class="line"></span><br><span class="line">引用,可以嵌套:</span><br><span class="line">&gt; 来自XXX</span><br><span class="line">&gt;&gt; 来自YYY</span><br><span class="line">&gt;&gt;&gt; 来自ZZZ</span><br><span class="line"></span><br><span class="line">加粗：</span><br><span class="line">**你好**</span><br><span class="line"></span><br><span class="line">斜体:</span><br><span class="line">*你好*</span><br><span class="line"></span><br><span class="line">斜体加粗:</span><br><span class="line">***你好***</span><br><span class="line"></span><br><span class="line">删除线：</span><br><span class="line">~~你好~~</span><br><span class="line"></span><br><span class="line">换行：</span><br><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">插入图片</span><br><span class="line">![名称可不填](路径)</span><br><span class="line"></span><br><span class="line"># MarkdownAllinOne快捷键</span><br><span class="line">Ctrl + BToggle bold  **测试**</span><br><span class="line">Ctrl + IToggle italic *测试*</span><br><span class="line">Ctrl + Shift + ]Toggle heading (uplevel) </span><br><span class="line">Ctrl + Shift + [Toggle heading (downlevel)</span><br><span class="line"></span><br><span class="line">Ctrl + MToggle math environment</span><br><span class="line">$f=1+x$</span><br><span class="line"></span><br><span class="line">Alt + CCheck/Uncheck task list item</span><br><span class="line"></span><br><span class="line">Ctrl + Shift + VToggle preview /off</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown阅读器&quot;&gt;&lt;a href=&quot;#Markdown阅读器&quot; class=&quot;headerlink&quot; title=&quot;Markdown阅读器&quot;&gt;&lt;/a&gt;Markdown阅读器&lt;/h1&gt;&lt;p&gt;这里推荐 &lt;code&gt;VsCode&lt;/code&gt; ，微软老牌阅读器&lt;
      
    
    </summary>
    
      <category term="随笔" scheme="http://syngnath.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>关于如何学习</title>
    <link href="http://syngnath.top/2019/05/23/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://syngnath.top/2019/05/23/随笔/关于如何学习/</id>
    <published>2019-05-23T05:19:00.000Z</published>
    <updated>2019-05-26T15:15:38.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="万事入门难"><a href="#万事入门难" class="headerlink" title="万事入门难"></a>万事入门难</h1><p><br></p><p>现在社会变化很快，时时刻刻都有新的东西产生，掌握适当的技巧来学习和熟悉一个新的东西是非常有必要的。当人接触一个新东西的时候，往往难以下手是很正常的，因为一无所知。我这里说下个人的经验：</p><p><strong>1.寻找合适的网上教学视频进行观看。</strong><br>网上的视频一般都是成体系的，能够带领初学者很好地接触入门。缺点是比较耗费时间</p><p><br></p><p><strong>2.直接阅读产品的源教学文档</strong><br>这种方法比较适合已经知道同类产品如何使用，然后只是了解下同样的操作方式不同的操作名称而已。</p><p><br></p><p><strong>3.阅读Blog</strong><br>google搜索对应的Blog介绍文章，一般写出文章的都是已经比较熟悉该项目的人，可以带你迅速避坑，记住关注下博客发表的时间，太老旧的要小心一点。</p><p><br></p><p><strong>4.看书</strong><br>最后还是最推荐这个方法，想最全面学习一个东西，还是得沉下心慢慢看书，看到不懂就上网查查，最老旧的往往是最实用的。</p><p><br><br><strong>知识，需要时间沉淀</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;万事入门难&quot;&gt;&lt;a href=&quot;#万事入门难&quot; class=&quot;headerlink&quot; title=&quot;万事入门难&quot;&gt;&lt;/a&gt;万事入门难&lt;/h1&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;现在社会变化很快，时时刻刻都有新的东西产生，掌握适当的技巧来学习和熟悉一个新的东西是非常有必
      
    
    </summary>
    
      <category term="随笔" scheme="http://syngnath.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo架构的Github Pages博客部署心路历程</title>
    <link href="http://syngnath.top/2019/05/22/%E9%9A%8F%E7%AC%94/Hexo%E6%9E%B6%E6%9E%84%E7%9A%84Github%20Pages%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    <id>http://syngnath.top/2019/05/22/随笔/Hexo架构的Github Pages博客部署心路历程/</id>
    <published>2019-05-22T10:26:00.000Z</published>
    <updated>2019-05-26T15:15:38.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>欢迎来到我的github博客，这个博客会被我用于记录一些学习笔记，将来可能会发布一些总结性的东西。</p><h1 id="博客简历心路历程"><a href="#博客简历心路历程" class="headerlink" title="博客简历心路历程"></a>博客简历心路历程</h1><p>这个博客弄了我两天，终于弄完了，这是第一个笔记，主要是不太熟悉一些命令操作踩坑了，并且实现自动化部署花了些时间。</p><p>找了好多主题不太满意，最后决定用这个主题是因为说明文档比较详细，但是直接copy进去是用不了的…所以又看了好多文章才实现。</p><p>现在我在本地有两个工作区，第一个是自己随笔写的自己看的，比较多东西，第二个是发布出去到博客上的上的，是需要花时间整理发布的。为了之后好说明，将前者设为<strong>A工作区</strong>，后者设为<strong>B工作区</strong></p><h2 id="A工作区方案-Onedrive-VSCode-gitlab"><a href="#A工作区方案-Onedrive-VSCode-gitlab" class="headerlink" title="A工作区方案:Onedrive + VSCode + gitlab"></a>A工作区方案:Onedrive + VSCode + gitlab</h2><p>Onedrive大家应该有用过，就是一个非常方便的同步工具，设置好文件夹好东西扔进去就能自动同步，而且不会怕锁定文件一切自动化不用理</p><p>VsCode主要是用于码字和git推送，需要装一些插件才能更好支持git和markdown，这里不再阐述</p><p>gitlab用于git托管，并且支持私有仓库，让你的隐私不被别人看到，国内的码云也可以</p><p>好了，现在资料本地一份，Onedrive云盘一份，gitlab一份，三重备份，还能随时回溯，nothing is better!</p><h2 id="B工作区方案-VScode-hexo-travis-cl-Snippet"><a href="#B工作区方案-VScode-hexo-travis-cl-Snippet" class="headerlink" title="B工作区方案: VScode + hexo + travis cl + Snippet"></a>B工作区方案: VScode + hexo + travis cl + Snippet</h2><p>简单说下，创建一个git工作区后，安装hexo，它会生成静态网页，这样我们可以本地预览或者推送到GitHUb或者码云等Git托管网站，它们有个Github pages的功能可以显示出该静态网页，从而实现Blog的功能。但是有人可能会问<strong>travis cl</strong>是个什么东西？</p><p>你想一下，每次本地码完字后，都要去工作区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>是不是感觉太麻烦，我只想安安静静写个文章而已。<br>所以travis cl可以帮你解决这个问题，<br>它会监控你的分支，当你push东西上去后，会自动帮你deploy一个静态网页，这样你就不用每次都输入命令了。</p><p>好了你现在要做的就是在vscode里面写好文章，确定没问题后就在vscode里push上去，ok！搞定</p><p>接下来介绍一下<strong>Snippet</strong>这个主题，这个主题是我见过最好的hexo主题框架，有钉钉通知推送，评论区功能也集成了N个插件，基本上你想要的它都有了，具体的不再评论，对应的使用手册很详细。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>坑1：hexo部署后的文件覆盖掉原来在master上的源文件<br>解决：把源文件整个文件夹Push到master后，创建分支hexo,然后把hexo设为默认分支，然后本地部署时，它自动推送的依然是master分支,这这样就不会影响到hexo的源文件</p><p>坑2：npm install 没反应，啥提示都没，导致下一步无法进行下去<br>解决：npm版本太低，去下载新版本的nodejs，一些博客推荐的版本都是上古版本</p><p>坑3: travis cl 部署失败，查看日志发现 rakefiles not found<br>解决：不要用主题包自带的<code>.travis.yml</code>文件，它会跳转到<code>_travis.sh</code>里面执行一大堆命令，注意要一句一句看把不需要的去掉，如果出错仔细阅读日记，尝试把出错导致语句去掉。</p><p><strong>注意GH_TOKEN，和GH_REF等${}里面装着一个字符串是你要在travis.cl网站里面对应工程setting里添加环境变量，它读取时就会自动替换，这样好处是防止泄露重要资料</strong><br><strong>但是有时候在travis加了环境变量也会失效还是要把字符串粘贴到文本中，这个具体对应功能不行再尝试</strong></p><p>好了，希望你接下来和我一样搭建出好的Blog，下面提供一些参考博客<br><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析</a><br><a href="https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="noopener">Travis Cl参考</a><br><a href="https://deserts.io/diy-a-comment-system/" target="_blank" rel="noopener">valine评论部署</a></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>现在工具流是在VsCode里码好字，使用VsCode管理两个Git工作区，然后挑选几篇笔记整理成文章，复制到对应的文件夹，推送。Done！看着窗外的月光1分钟后，Travis CL会自动帮我构建环境生成静态网页，并且通过钉钉(邮件)通知我构建成功。GitHub博客就可以访问到最新的文章区，如果有问题，也可以在下面的评论区进行评论。多么美好的工作流。好了，今天的博客介绍就到这里!</p><h1 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h1><p>会记录一些关于C家族笔记和Unity相关东西，AI算法等，主要和游戏相关。<br><code>Study for developing our country</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;欢迎来到我的github博客，这个博客会被我用于记录一些学习笔记，将来可能会发布一些总结性的东西。&lt;/p&gt;
&lt;h1 id=&quot;博客简历心路历程
      
    
    </summary>
    
      <category term="随笔" scheme="http://syngnath.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Travis Cl" scheme="http://syngnath.top/tags/Travis-Cl/"/>
    
      <category term="Hexo" scheme="http://syngnath.top/tags/Hexo/"/>
    
      <category term="VsCode" scheme="http://syngnath.top/tags/VsCode/"/>
    
  </entry>
  
</feed>
