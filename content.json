{"meta":{"title":"Syngnath个人技术博客-攀登代码之巅","subtitle":null,"description":"研究，分享和技术有关一切，细节决定成败,格局决定成功,境界决定成就","author":"Syngnath","url":"http://syngnath.top","root":"/"},"pages":[],"posts":[{"title":"Unity研究：C#和Unity的Event事件区别与使用","slug":"Unity/CSharp和Unity的Event事件区别与使用","date":"2019-05-26T04:45:00.000Z","updated":"2019-05-27T13:29:47.948Z","comments":true,"path":"2019/05/26/Unity/CSharp和Unity的Event事件区别与使用/","link":"","permalink":"http://syngnath.top/2019/05/26/Unity/CSharp和Unity的Event事件区别与使用/","excerpt":"","text":"前言现在设计游戏趋向于事件驱动，即当一个事件发生时，如主角捡到一个血包，发射一颗子弹，或者想让游戏里所有的物体需要进入第二阶段的状态，通过一个事件广播给游戏中的相关对象，使它们根据该恰当做出反应，从而使游戏驱动起来。事件一般是以数据包形式送出，其包含事件的信息，如发送者，或者时间戳等，当然根据实际情况作出改变。而这些的一切都要围绕Event作为核心，不过在说明Event之前先了解它的前身–delegate。 Delegate委托的基本声明和基本使用先看下委托的定义：C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。 简单来说，委托就是存储方法容器。C# 基于这个基础做了一定优化封装。下面介绍下delegate基本使用:我想声明一个叫BroadCast的委托，将来用于存放方法，它接收string参数，并且返回值为void。而声明一个委托相当于声明一个新类，所有可以声明类的地方都可以声明委托。public delegate void BroadCast(string msg);这样它就是个可以存放和它标签一样，即同样是接收string参数，返回void的方法。 接着我们使用它去定义一些事件容器，如12public BroadCast broadCastA;public BroadCast broadCastB; 好了，接着在下面添加两个方法，一个叫BroadCastCore，用于调用委托里存放的东西，另外一个叫Func1的方法，Func1存放到broadCastA内，和broadCastA具备同样的标签，只要对broadCastA执行Invoke方法并且传递对应参数，那么里面存放的对应方法就会被调用并且接受到传递过来的参数。12345678910void BroadCastCore()&#123; // new一个委托对象 broadCastA = Func1; //或者broadCastA = new broadCastA(Func1); 前者实际上等于后者，只是编译器帮忙省略了new的步骤 // 调用委托 broadCastA.Invoke(&quot;&quot;);&#125;void Func1(string receiveMsg)&#123; print(&quot;I Receive the msg : receiveMsg&quot;);&#125; 多播委托多播委托使用了一个叫委托链的概念，简单来说就是把很多方法存放到一个容器中，然后调用这个容器时容器会将里面的方法每个都调用一次。使用 += 关键词可以注册方法broadCastA += Func1;broadCastA += Func2;broadCastA += Func3; 使用 -= 关键词可以卸掉原来注册方法broadCastA -= Func1;broadCastA -= Func2;broadCastA -= Func3;所以对相关包含委托类封装时要提供注册和卸除两个方法 但是这里有个坑，因为一旦不小心使用了 = 就会重置覆盖掉之前所有注册的方法如：broadCastA += Func1;broadCastA += Func2;broadCastA = Func3;事实上只存放Func3方法。 所以接下来介绍下面的 ‘event’ 修饰关键词 event修饰词在原来委托定义基础上，加上event修饰词：public event BroadCast broadCastA;好了，现在 = 就会被禁止使用了，只能使用 += 和 -= 增加和删除，所以这就是多播委托的最终形态了。 UnityEventUnityEvent基于C#委托的基础作出一定的封装，并且融入到Unity框架里，既可以把它当做一个普通委托在脚本中使用，也可以把它public在Unity面板中拖拽注册事件。 声明和定义创建一个继承UnityEvent的类即可如：123public class BossEvent : UnityEvent&lt;string&gt;&#123;&#125; 和之前上面c#委托声明 public delegate void BroadCast(string msg); 一个意思 接着定义一个事件容器，用属性来自动new一个Event对象1234567891011BossEvent informEvent;public InformEvent &#123; get &#123; if (informEvent == null) informEvent = new BossEvent(); return informEvent; &#125; set &#123; informEvent = value; &#125;&#125; 事件注册首先F12看UnityEvent写了什么12345678910111213namespace UnityEngine.Events&#123; public abstract class UnityEvent&lt;T0&gt; : UnityEventBase &#123; [RequiredByNativeCode] public UnityEvent(); public void AddListener(UnityAction&lt;T0&gt; call); public void Invoke(T0 arg0); public void RemoveListener(UnityAction&lt;T0&gt; call); protected override MethodInfo FindMethod_Impl(string name, object targetObj); &#125;&#125; 需要传入UnityAction声明的参数，尝试声明一个UnityAction发现它利用多态性封装了0-4个泛型参数的Action无返回值委托1234public delegate void UnityAction();public delegate void UnityAction&lt;T0&gt;(T0 arg0);public delegate void UnityAction&lt;T0, T1&gt;(T0 arg0, T1 arg1);... 那么明白本质后用起来就很简单了 LambadainformEvent.AddListener((msg)=&gt;{print(“Get Msg:” + msg)});Lambada法力无边，另外注意Lambada里面方法如果调用外部变量，可能会导致GC 方法informEvent.AddListener(同样签名方法名); EventSystem和EventUnity里的EventSystem和Event主要是负责一些UI状态，用户输入输出，鼠标点击等事件的封装和监控。12345678910111213141516171819202122232425using UnityEngine;public class Example : MonoBehaviour&#123; void OnGUI() &#123; Event m_Event = Event.current; if (m_Event.type == EventType.MouseDown) &#123; Debug.Log(&quot;Mouse Down.&quot;); &#125; if (m_Event.type == EventType.MouseDrag) &#123; Debug.Log(&quot;Mouse Dragged.&quot;); &#125; if (m_Event.type == EventType.MouseUp) &#123; Debug.Log(&quot;Mouse Up.&quot;); &#125; &#125;&#125;` 这里不再阐述，其主要是负责Unity框架内事件的监听和接口封装，有需要使用时查API即可。 总结事件驱动模式可以帮助我们解决不同模块间的交流而不得不对象持有相互对象从而导致耦合性增加的问题，比较常用主要是两种： 订阅-广播 模式通过封装一个&lt;string, UnityEvent&gt;字典，提供事件的注册和卸除接口,再创建一个数据包的类DataBundle封装数据，从而实现广播数据包给已注册的对象。DataBundle可以封装一个&lt;string, object&gt;用于存放一些事件属性或者其他任意的东西，从而使事件本身带有一些数据或者一些状态，一些属性，更加多样化。 主动监听模式核心思想是谁感兴趣，谁主动监听，一般使用观察者模式是在比较具体的模块上使用，根据实际情况增添相应的接口。下面举个例子： 枚举类EventType：存放事件，里面的事件对应的编号要明确写出，不要自动迭代 管理类EventMng：EventType 定义的变量 eventMain提供一个事件的监听方法Observe(EventType type){return eventMain==type;}给外部监听提供一个事件的触发方法Trigger(EventType type){}给外部触发Update：监控eventMain，如果eventMain不为null，则在下一帧清除 兴趣类Person:这时候假设有个类Person对EventType里某个事件感兴趣这时候只要在update里if(EventMng.Instance.Observe()){//执行代码段}就能监听对应事件执行相应代码 可以看到，主动监听模式使用起来比较简单，并且不需要事件的注册，只需要一个存放事件一帧的容器即可，简单，有效","categories":[{"name":"Unity","slug":"Unity","permalink":"http://syngnath.top/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://syngnath.top/tags/Unity/"},{"name":"C#","slug":"C","permalink":"http://syngnath.top/tags/C/"}]},{"title":"Markdown一些使用诀窍","slug":"随笔/Markdown一些使用诀窍","date":"2019-05-25T04:19:00.000Z","updated":"2019-05-27T13:29:47.948Z","comments":true,"path":"2019/05/25/随笔/Markdown一些使用诀窍/","link":"","permalink":"http://syngnath.top/2019/05/25/随笔/Markdown一些使用诀窍/","excerpt":"","text":"Markdown阅读器这里推荐 VsCode ，微软老牌阅读器vscode要安装增强插件来更好支持markdown 插件：GitLens – Git分支显示Markdown Preview Enhanced – 支持Markdown外部导入vscode-pdf –支持pdf显示MarkdownAllinOne – 快捷键 相关文章Markdown基本语法Markdown增强插件使用说明 Markdown语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 一级标题## 二级### 三级分割线：---- 列表1级 - 列表二级Tab + “-” - 列表三级 - 2.afwaf-有一个以上就行-两边加：表示文字居中-右边加：表示文字居右姓名|班别|学号:--:|:--:|:--:yeshujun|2-class|1502moss|3-class|1504姓名|班别|学号--|--|--yeshujun|2-class|1502moss|3-class|1504引用,可以嵌套:&gt; 来自XXX&gt;&gt; 来自YYY&gt;&gt;&gt; 来自ZZZ加粗：**你好**斜体:*你好*斜体加粗:***你好***删除线：~~你好~~换行：&lt;br/&gt;插入图片![名称可不填](路径)# MarkdownAllinOne快捷键Ctrl + B Toggle bold **测试**Ctrl + I Toggle italic *测试*Ctrl + Shift + ] Toggle heading (uplevel) Ctrl + Shift + [ Toggle heading (downlevel)Ctrl + M Toggle math environment$f=1+x$Alt + C Check/Uncheck task list itemCtrl + Shift + V Toggle preview /off","categories":[{"name":"随笔","slug":"随笔","permalink":"http://syngnath.top/categories/随笔/"}],"tags":[]},{"title":"关于如何学习","slug":"随笔/关于如何学习","date":"2019-05-23T05:19:00.000Z","updated":"2019-05-27T13:29:47.948Z","comments":true,"path":"2019/05/23/随笔/关于如何学习/","link":"","permalink":"http://syngnath.top/2019/05/23/随笔/关于如何学习/","excerpt":"","text":"万事入门难 现在社会变化很快，时时刻刻都有新的东西产生，掌握适当的技巧来学习和熟悉一个新的东西是非常有必要的。当人接触一个新东西的时候，往往难以下手是很正常的，因为一无所知。我这里说下个人的经验： 1.寻找合适的网上教学视频进行观看。网上的视频一般都是成体系的，能够带领初学者很好地接触入门。缺点是比较耗费时间 2.直接阅读产品的源教学文档这种方法比较适合已经知道同类产品如何使用，然后只是了解下同样的操作方式不同的操作名称而已。 3.阅读Bloggoogle搜索对应的Blog介绍文章，一般写出文章的都是已经比较熟悉该项目的人，可以带你迅速避坑，记住关注下博客发表的时间，太老旧的要小心一点。 4.看书最后还是最推荐这个方法，想最全面学习一个东西，还是得沉下心慢慢看书，看到不懂就上网查查，最老旧的往往是最实用的。 知识，需要时间沉淀","categories":[{"name":"随笔","slug":"随笔","permalink":"http://syngnath.top/categories/随笔/"}],"tags":[]},{"title":"Hexo架构的Github Pages博客部署心路历程","slug":"随笔/Hexo架构的Github Pages博客部署心路历程","date":"2019-05-22T10:26:00.000Z","updated":"2019-05-27T13:29:47.948Z","comments":true,"path":"2019/05/22/随笔/Hexo架构的Github Pages博客部署心路历程/","link":"","permalink":"http://syngnath.top/2019/05/22/随笔/Hexo架构的Github Pages博客部署心路历程/","excerpt":"","text":"简介欢迎来到我的github博客，这个博客会被我用于记录一些学习笔记，将来可能会发布一些总结性的东西。 博客简历心路历程这个博客弄了我两天，终于弄完了，这是第一个笔记，主要是不太熟悉一些命令操作踩坑了，并且实现自动化部署花了些时间。 找了好多主题不太满意，最后决定用这个主题是因为说明文档比较详细，但是直接copy进去是用不了的…所以又看了好多文章才实现。 现在我在本地有两个工作区，第一个是自己随笔写的自己看的，比较多东西，第二个是发布出去到博客上的上的，是需要花时间整理发布的。为了之后好说明，将前者设为A工作区，后者设为B工作区 A工作区方案:Onedrive + VSCode + gitlabOnedrive大家应该有用过，就是一个非常方便的同步工具，设置好文件夹好东西扔进去就能自动同步，而且不会怕锁定文件一切自动化不用理 VsCode主要是用于码字和git推送，需要装一些插件才能更好支持git和markdown，这里不再阐述 gitlab用于git托管，并且支持私有仓库，让你的隐私不被别人看到，国内的码云也可以 好了，现在资料本地一份，Onedrive云盘一份，gitlab一份，三重备份，还能随时回溯，nothing is better! B工作区方案: VScode + hexo + travis cl + Snippet简单说下，创建一个git工作区后，安装hexo，它会生成静态网页，这样我们可以本地预览或者推送到GitHUb或者码云等Git托管网站，它们有个Github pages的功能可以显示出该静态网页，从而实现Blog的功能。但是有人可能会问travis cl是个什么东西？ 你想一下，每次本地码完字后，都要去工作区12hexo clean &amp;&amp; hexo ghexo d 是不是感觉太麻烦，我只想安安静静写个文章而已。所以travis cl可以帮你解决这个问题，它会监控你的分支，当你push东西上去后，会自动帮你deploy一个静态网页，这样你就不用每次都输入命令了。 好了你现在要做的就是在vscode里面写好文章，确定没问题后就在vscode里push上去，ok！搞定 接下来介绍一下Snippet这个主题，这个主题是我见过最好的hexo主题框架，有钉钉通知推送，评论区功能也集成了N个插件，基本上你想要的它都有了，具体的不再评论，对应的使用手册很详细。 踩坑坑1：hexo部署后的文件覆盖掉原来在master上的源文件解决：把源文件整个文件夹Push到master后，创建分支hexo,然后把hexo设为默认分支，然后本地部署时，它自动推送的依然是master分支,这这样就不会影响到hexo的源文件 坑2：npm install 没反应，啥提示都没，导致下一步无法进行下去解决：npm版本太低，去下载新版本的nodejs，一些博客推荐的版本都是上古版本 坑3: travis cl 部署失败，查看日志发现 rakefiles not found解决：不要用主题包自带的.travis.yml文件，它会跳转到_travis.sh里面执行一大堆命令，注意要一句一句看把不需要的去掉，如果出错仔细阅读日记，尝试把出错导致语句去掉。 注意GH_TOKEN，和GH_REF等${}里面装着一个字符串是你要在travis.cl网站里面对应工程setting里添加环境变量，它读取时就会自动替换，这样好处是防止泄露重要资料但是有时候在travis加了环境变量也会失效还是要把字符串粘贴到文本中，这个具体对应功能不行再尝试 好了，希望你接下来和我一样搭建出好的Blog，下面提供一些参考博客最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析Travis Cl参考valine评论部署 结论现在工具流是在VsCode里码好字，使用VsCode管理两个Git工作区，然后挑选几篇笔记整理成文章，复制到对应的文件夹，推送。Done！看着窗外的月光1分钟后，Travis CL会自动帮我构建环境生成静态网页，并且通过钉钉(邮件)通知我构建成功。GitHub博客就可以访问到最新的文章区，如果有问题，也可以在下面的评论区进行评论。多么美好的工作流。好了，今天的博客介绍就到这里! 博客内容会记录一些关于C家族笔记和Unity相关东西，AI算法等，主要和游戏相关。Study for developing our country","categories":[{"name":"随笔","slug":"随笔","permalink":"http://syngnath.top/categories/随笔/"}],"tags":[{"name":"Travis Cl","slug":"Travis-Cl","permalink":"http://syngnath.top/tags/Travis-Cl/"},{"name":"Hexo","slug":"Hexo","permalink":"http://syngnath.top/tags/Hexo/"},{"name":"VsCode","slug":"VsCode","permalink":"http://syngnath.top/tags/VsCode/"}]}]}